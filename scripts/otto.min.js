const translations = { 'zh-CN': { 'otto.title': 'ü§ñ Otto Êú∫Âô®‰∫∫ÊéßÂà∂', 'otto.status.idle': 'Áä∂ÊÄÅ: Á©∫Èó≤', 'otto.status.moving': 'Áä∂ÊÄÅ: ÁßªÂä®‰∏≠', 'otto.direction': 'ÊñπÂêëÊéßÂà∂', 'otto.forward': '‚¨ÜÔ∏è ÂâçËøõ', 'otto.left': '‚¨ÖÔ∏è Â∑¶ËΩ¨', 'otto.right': '‚û°Ô∏è Âè≥ËΩ¨', 'otto.backward': '‚¨áÔ∏è ÂêéÈÄÄ', 'otto.stop': '‚èπÔ∏è ÂÅúÊ≠¢', 'otto.dance': 'ËàûËπàÂä®‰Ωú', 'otto.jump': 'Ë∑≥Ë∑É', 'otto.swing': 'ÊëáÊëÜ', 'otto.moonwalk': 'Â§™Á©∫Ê≠•', 'otto.bend': 'ÂºØËÖ∞', 'otto.shake_leg': 'ÊëáËÖø', 'otto.updown': '‰∏ä‰∏ã', 'otto.tiptoe_swing': 'Ë∏ÆËÑöÊëáÊëÜ', 'otto.jitter': 'ÊäñÂä®', 'otto.ascending_turn': '‰∏äÂçáËΩ¨Ë∫´', 'otto.crusaito': 'Crusaito', 'otto.flapping': 'ÊãçÊâì', 'otto.hands': 'ÊâãÈÉ®Âä®‰Ωú', 'otto.hands_up': '‰∏æÊâã', 'otto.hands_down': 'ÊîæÊâã', 'otto.hand_wave': 'Êå•Êâã', 'otto.emoji': 'Ë°®ÊÉÖÊéßÂà∂', 'otto.emoji.happy': 'üòä ÂºÄÂøÉ', 'otto.emoji.sad': 'üò¢ ÈöæËøá', 'otto.emoji.angry': 'üò† ÁîüÊ∞î', 'otto.emoji.surprised': 'üò≤ ÊÉäËÆ∂', 'otto.emoji.thinking': 'ü§î ÊÄùËÄÉ', 'otto.emoji.neutral': 'üòê ‰∏≠ÊÄß', 'otto.voice_control': 'üé§ ËØ≠Èü≥ÊéßÂà∂ (ËØ≠Èü≥Êåá‰ª§)', 'otto.voice_start': 'üé§ ÂºÄÂßãËØ≠Èü≥ÊéßÂà∂', 'otto.voice_stop': '‚èπÔ∏è ÂÅúÊ≠¢ÂΩïÈü≥', 'otto.voice_hint': 'ÁÇπÂáªÊåâÈíÆÂπ∂ËØ¥ËØù‰ª•ÊéßÂà∂OttoÊú∫Âô®‰∫∫„ÄÇAI‰ºöÁêÜËß£ÊÇ®ÁöÑÊåá‰ª§Âπ∂Ëá™Âä®ÊéßÂà∂Otto„ÄÇÁ§∫‰æã: "Otto ÂâçËøõ", "Otto Ë∑≥Ë∑É", "Otto ÂÅúÊ≠¢"', 'otto.voice_status_recording': 'üé§ Ê≠£Âú®ÂΩïÈü≥... ËØ∑ËØ¥ËØùÔºÅ', 'otto.voice_status_processing': 'ü§î Â§ÑÁêÜ‰∏≠... Ê≠£Âú®ÂèëÈÄÅÂà∞AI...', 'otto.voice_status_sent': '‚úÖ Êåá‰ª§Â∑≤ÂèëÈÄÅÔºÅAIÊ≠£Âú®Â§ÑÁêÜ...' }, 'zh-TW': { 'otto.title': 'ü§ñ Otto Ê©üÂô®‰∫∫ÊéßÂà∂', 'otto.status.idle': 'ÁãÄÊÖã: ÈñíÁΩÆ', 'otto.status.moving': 'ÁãÄÊÖã: ÁßªÂãï‰∏≠', 'otto.direction': 'ÊñπÂêëÊéßÂà∂', 'otto.forward': '‚¨ÜÔ∏è ÂâçÈÄ≤', 'otto.left': '‚¨ÖÔ∏è Â∑¶ËΩâ', 'otto.right': '‚û°Ô∏è Âè≥ËΩâ', 'otto.backward': '‚¨áÔ∏è ÂæåÈÄÄ', 'otto.stop': '‚èπÔ∏è ÂÅúÊ≠¢', 'otto.dance': 'ËàûËπàÂãï‰Ωú', 'otto.jump': 'Ë∑≥Ë∫ç', 'otto.swing': 'ÊêñÊì∫', 'otto.moonwalk': 'Â§™Á©∫Ê≠•', 'otto.bend': 'ÂΩéËÖ∞', 'otto.shake_leg': 'ÊêñËÖø', 'otto.updown': '‰∏ä‰∏ã', 'otto.tiptoe_swing': 'Ë∏ÆËÖ≥ÊêñÊì∫', 'otto.jitter': 'ÊäñÂãï', 'otto.ascending_turn': '‰∏äÂçáËΩâË∫´', 'otto.crusaito': 'Crusaito', 'otto.flapping': 'ÊãçÊâì', 'otto.hands': 'ÊâãÈÉ®Âãï‰Ωú', 'otto.hands_up': 'ËàâÊâã', 'otto.hands_down': 'ÊîæÊâã', 'otto.hand_wave': 'ÊèÆÊâã', 'otto.emoji': 'Ë°®ÊÉÖÊéßÂà∂', 'otto.emoji.happy': 'üòä ÈñãÂøÉ', 'otto.emoji.sad': 'üò¢ Èõ£ÈÅé', 'otto.emoji.angry': 'üò† ÁîüÊ∞£', 'otto.emoji.surprised': 'üò≤ È©öË®ù', 'otto.emoji.thinking': 'ü§î ÊÄùËÄÉ', 'otto.emoji.neutral': 'üòê ‰∏≠ÊÄß', 'otto.voice_control': 'üé§ Ë™ûÈü≥ÊéßÂà∂ (Ë™ûÈü≥Êåá‰ª§)', 'otto.voice_start': 'üé§ ÈñãÂßãË™ûÈü≥ÊéßÂà∂', 'otto.voice_stop': '‚èπÔ∏è ÂÅúÊ≠¢ÈåÑÈü≥', 'otto.voice_hint': 'ÈªûÊìäÊåâÈàï‰∏¶Ë™™Ë©±‰ª•ÊéßÂà∂OttoÊ©üÂô®‰∫∫„ÄÇAIÊúÉÁêÜËß£ÊÇ®ÁöÑÊåá‰ª§‰∏¶Ëá™ÂãïÊéßÂà∂Otto„ÄÇÁØÑ‰æã: "Otto ÂâçÈÄ≤", "Otto Ë∑≥Ë∫ç", "Otto ÂÅúÊ≠¢"', 'otto.voice_status_recording': 'üé§ Ê≠£Âú®ÈåÑÈü≥... Ë´ãË™™Ë©±ÔºÅ', 'otto.voice_status_processing': 'ü§î ËôïÁêÜ‰∏≠... Ê≠£Âú®ÁôºÈÄÅÂà∞AI...', 'otto.voice_status_sent': '‚úÖ Êåá‰ª§Â∑≤ÁôºÈÄÅÔºÅAIÊ≠£Âú®ËôïÁêÜ...' }, 'en-US': { 'otto.title': 'ü§ñ Otto Robot Control', 'otto.status.idle': 'Status: Idle', 'otto.status.moving': 'Status: Moving', 'otto.direction': 'Direction Control', 'otto.forward': '‚¨ÜÔ∏è Forward', 'otto.left': '‚¨ÖÔ∏è Left', 'otto.right': '‚û°Ô∏è Right', 'otto.backward': '‚¨áÔ∏è Backward', 'otto.stop': '‚èπÔ∏è Stop', 'otto.dance': 'Dance Moves', 'otto.jump': 'Jump', 'otto.swing': 'Swing', 'otto.moonwalk': 'Moonwalk', 'otto.bend': 'Bend', 'otto.shake_leg': 'Shake Leg', 'otto.updown': 'Up & Down', 'otto.tiptoe_swing': 'Tiptoe Swing', 'otto.jitter': 'Jitter', 'otto.ascending_turn': 'Ascending Turn', 'otto.crusaito': 'Crusaito', 'otto.flapping': 'Flapping', 'otto.hands': 'Hand Actions', 'otto.hands_up': 'Hands Up', 'otto.hands_down': 'Hands Down', 'otto.hand_wave': 'Hand Wave', 'otto.emoji': 'Emoji Control', 'otto.emoji.happy': 'üòä Happy', 'otto.emoji.sad': 'üò¢ Sad', 'otto.emoji.angry': 'üò† Angry', 'otto.emoji.surprised': 'üò≤ Surprised', 'otto.emoji.thinking': 'ü§î Thinking', 'otto.emoji.neutral': 'üòê Neutral', 'otto.voice_control': 'üé§ Voice Control (Voice Command)', 'otto.voice_start': 'üé§ Start Voice Control', 'otto.voice_stop': '‚èπÔ∏è Stop Recording', 'otto.voice_hint': 'Click the button and speak to control Otto robot. The AI will understand your commands and control Otto automatically. Examples: "Otto go forward", "Otto jump", "Otto stop"', 'otto.voice_status_recording': 'üé§ Recording... Speak now!', 'otto.voice_status_processing': 'ü§î Processing... Sending to AI...', 'otto.voice_status_sent': '‚úÖ Command sent! AI is processing...' }, 'vi-VN': { 'otto.title': 'ü§ñ ƒêi·ªÅu Khi·ªÉn Robot Otto', 'otto.status.idle': 'Tr·∫°ng th√°i: Nh√†n r·ªói', 'otto.status.moving': 'Tr·∫°ng th√°i: ƒêang di chuy·ªÉn', 'otto.direction': 'ƒêi·ªÅu Khi·ªÉn H∆∞·ªõng', 'otto.forward': '‚¨ÜÔ∏è Ti·∫øn', 'otto.left': '‚¨ÖÔ∏è Tr√°i', 'otto.right': '‚û°Ô∏è Ph·∫£i', 'otto.backward': '‚¨áÔ∏è L√πi', 'otto.stop': '‚èπÔ∏è D·ª´ng', 'otto.dance': 'ƒê·ªông T√°c Nh·∫£y', 'otto.jump': 'Nh·∫£y', 'otto.swing': 'ƒêu ƒê∆∞a', 'otto.moonwalk': 'Moonwalk', 'otto.bend': 'C√∫i', 'otto.shake_leg': 'L·∫Øc Ch√¢n', 'otto.updown': 'L√™n & Xu·ªëng', 'otto.tiptoe_swing': 'ƒêu ƒê∆∞a Nh√≥n Ch√¢n', 'otto.jitter': 'Rung', 'otto.ascending_turn': 'Xoay L√™n', 'otto.crusaito': 'Crusaito', 'otto.flapping': 'V·ªó', 'otto.hands': 'ƒê·ªông T√°c Tay', 'otto.hands_up': 'Gi∆° Tay', 'otto.hands_down': 'H·∫° Tay', 'otto.hand_wave': 'V·∫´y Tay', 'otto.emoji': 'ƒêi·ªÅu Khi·ªÉn Emoji', 'otto.emoji.happy': 'üòä Vui', 'otto.emoji.sad': 'üò¢ Bu·ªìn', 'otto.emoji.angry': 'üò† Gi·∫≠n', 'otto.emoji.surprised': 'üò≤ Ng·∫°c Nhi√™n', 'otto.emoji.thinking': 'ü§î Suy Nghƒ©', 'otto.emoji.neutral': 'üòê Trung T√≠nh', 'otto.voice_control': 'üé§ ƒêi·ªÅu Khi·ªÉn Gi·ªçng N√≥i (L·ªánh Gi·ªçng N√≥i)', 'otto.voice_start': 'üé§ B·∫Øt ƒê·∫ßu ƒêi·ªÅu Khi·ªÉn Gi·ªçng N√≥i', 'otto.voice_stop': '‚èπÔ∏è D·ª´ng Ghi √Çm', 'otto.voice_hint': 'Nh·∫•n n√∫t v√† n√≥i ƒë·ªÉ ƒëi·ªÅu khi·ªÉn robot Otto. AI s·∫Ω hi·ªÉu l·ªánh c·ªßa b·∫°n v√† t·ª± ƒë·ªông ƒëi·ªÅu khi·ªÉn Otto. V√≠ d·ª•: "Otto ƒëi v·ªÅ ph√≠a tr∆∞·ªõc", "Otto nh·∫£y", "Otto d·ª´ng l·∫°i"', 'otto.voice_status_recording': 'üé§ ƒêang ghi √¢m... Vui l√≤ng n√≥i!', 'otto.voice_status_processing': 'ü§î ƒêang x·ª≠ l√Ω... ƒêang g·ª≠i ƒë·∫øn AI...', 'otto.voice_status_sent': '‚úÖ L·ªánh ƒë√£ ƒë∆∞·ª£c g·ª≠i! AI ƒëang x·ª≠ l√Ω...' }, 'zh-CN': { 'otto.title': 'ü§ñ Otto Êú∫Âô®‰∫∫ÊéßÂà∂', 'otto.status.idle': 'Áä∂ÊÄÅ: Á©∫Èó≤', 'otto.status.moving': 'Áä∂ÊÄÅ: ÁßªÂä®‰∏≠', 'otto.direction': 'ÊñπÂêëÊéßÂà∂', 'otto.forward': '‚¨ÜÔ∏è ÂâçËøõ', 'otto.left': '‚¨ÖÔ∏è Â∑¶ËΩ¨', 'otto.right': '‚û°Ô∏è Âè≥ËΩ¨', 'otto.backward': '‚¨áÔ∏è ÂêéÈÄÄ', 'otto.stop': '‚èπÔ∏è ÂÅúÊ≠¢', 'otto.dance': 'ËàûËπàÂä®‰Ωú', 'otto.jump': 'Ë∑≥Ë∑É', 'otto.swing': 'ÊëáÊëÜ', 'otto.moonwalk': 'Â§™Á©∫Ê≠•', 'otto.bend': 'ÂºØËÖ∞', 'otto.shake_leg': 'ÊëáËÖø', 'otto.updown': '‰∏ä‰∏ã', 'otto.tiptoe_swing': 'Ë∏ÆËÑöÊëáÊëÜ', 'otto.jitter': 'ÊäñÂä®', 'otto.ascending_turn': '‰∏äÂçáËΩ¨Ë∫´', 'otto.crusaito': 'Crusaito', 'otto.flapping': 'ÊãçÊâì', 'otto.hands': 'ÊâãÈÉ®Âä®‰Ωú', 'otto.hands_up': '‰∏æÊâã', 'otto.hands_down': 'ÊîæÊâã', 'otto.hand_wave': 'Êå•Êâã', 'otto.emoji': 'Ë°®ÊÉÖÊéßÂà∂', 'otto.emoji.happy': 'üòä ÂºÄÂøÉ', 'otto.emoji.sad': 'üò¢ ÈöæËøá', 'otto.emoji.angry': 'üò† ÁîüÊ∞î', 'otto.emoji.surprised': 'üò≤ ÊÉäËÆ∂', 'otto.emoji.thinking': 'ü§î ÊÄùËÄÉ', 'otto.emoji.neutral': 'üòê ‰∏≠ÊÄß', 'otto.voice_control': 'üé§ ËØ≠Èü≥ÊéßÂà∂ (ËØ≠Èü≥Êåá‰ª§)', 'otto.voice_start': 'üé§ ÂºÄÂßãËØ≠Èü≥ÊéßÂà∂', 'otto.voice_stop': '‚èπÔ∏è ÂÅúÊ≠¢ÂΩïÈü≥', 'otto.voice_hint': 'ÁÇπÂáªÊåâÈíÆÂπ∂ËØ¥ËØù‰ª•ÊéßÂà∂OttoÊú∫Âô®‰∫∫„ÄÇAI‰ºöÁêÜËß£ÊÇ®ÁöÑÊåá‰ª§Âπ∂Ëá™Âä®ÊéßÂà∂Otto„ÄÇÁ§∫‰æã: "Otto ÂâçËøõ", "Otto Ë∑≥Ë∑É", "Otto ÂÅúÊ≠¢"', 'otto.voice_status_recording': 'üé§ Ê≠£Âú®ÂΩïÈü≥... ËØ∑ËØ¥ËØùÔºÅ', 'otto.voice_status_processing': 'ü§î Â§ÑÁêÜ‰∏≠... Ê≠£Âú®ÂèëÈÄÅÂà∞AI...', 'otto.voice_status_sent': '‚úÖ Êåá‰ª§Â∑≤ÂèëÈÄÅÔºÅAIÊ≠£Âú®Â§ÑÁêÜ...', 'otto.device_discovery': 'üîç ËÆæÂ§áÂèëÁé∞', 'otto.scan_qr': 'üì∑ Êâ´Êèè‰∫åÁª¥Á†Å', 'otto.saved_devices': 'üìã Â∑≤‰øùÂ≠òËÆæÂ§á', 'otto.stop_scan': 'ÂÅúÊ≠¢Êâ´Êèè', 'otto.no_device_found': 'Êú™ÊâæÂà∞ËÆæÂ§á', 'otto.connect': 'ËøûÊé•', 'otto.disconnect': 'Êñ≠ÂºÄËøûÊé•', 'otto.remove': 'Âà†Èô§', 'otto.online': 'Âú®Á∫ø', 'otto.offline': 'Á¶ªÁ∫ø', 'otto.show_qr_lcd': 'üì∫ Âú®LCDÊòæÁ§∫QRÁ†Å' }, 'zh-TW': { 'otto.device_discovery': 'üîç Ë£ùÁΩÆÁôºÁèæ', 'otto.scan_qr': 'üì∑ ÊéÉÊèè QR Code', 'otto.saved_devices': 'üìã Â∑≤ÂÑ≤Â≠òË£ùÁΩÆ', 'otto.stop_scan': 'ÂÅúÊ≠¢ÊéÉÊèè', 'otto.no_device_found': 'Êâæ‰∏çÂà∞Ë£ùÁΩÆ', 'otto.connect': 'ÈÄ£Êé•', 'otto.disconnect': 'Êñ∑ÈñãÈÄ£Êé•', 'otto.remove': 'Âà™Èô§', 'otto.online': 'Á∑ö‰∏ä', 'otto.offline': 'Èõ¢Á∑ö', 'otto.show_qr_lcd': 'üì∫ Âú®LCDÈ°ØÁ§∫QRÁ¢º' }, 'vi-VN': { 'otto.device_discovery': 'üîç T√¨m Thi·∫øt B·ªã', 'otto.scan_qr': 'üì∑ Qu√©t QR Code', 'otto.saved_devices': 'üìã Thi·∫øt B·ªã ƒê√£ L∆∞u', 'otto.stop_scan': 'D·ª´ng Qu√©t', 'otto.no_device_found': 'Kh√¥ng t√¨m th·∫•y thi·∫øt b·ªã', 'otto.connect': 'K·∫øt N·ªëi', 'otto.disconnect': 'Ng·∫Øt K·∫øt N·ªëi', 'otto.remove': 'X√≥a', 'otto.online': 'Tr·ª±c Tuy·∫øn', 'otto.offline': 'Ngo·∫°i Tuy·∫øn', 'otto.show_qr_lcd': 'üì∫ Hi·ªÉn Th·ªã QR Tr√™n LCD' }, 'en-US': { 'otto.show_qr_lcd': 'üì∫ Show QR on LCD' }, 'ja-JP': { 'otto.show_qr_lcd': 'üì∫ LCD„Å´QR„Ç≥„Éº„Éâ„ÇíË°®Á§∫' }, 'ko-KR': { 'otto.show_qr_lcd': 'üì∫ LCDÏóê QR ÌëúÏãú' }, 'th-TH': { 'otto.show_qr_lcd': 'üì∫ ‡πÅ‡∏™‡∏î‡∏á QR ‡∏ö‡∏ô LCD' } }; function getCurrentLanguage() { const saved = localStorage.getItem('otto_language'); if (saved && translations[saved]) return saved; const browserLang = navigator.language || navigator.userLanguage; if (browserLang.startsWith('zh')) { return browserLang === 'zh-TW' || browserLang === 'zh-Hant' ? 'zh-TW' : 'zh-CN'; } if (translations[browserLang]) return browserLang; return 'en-US'; } function changeLanguage(lang) { localStorage.setItem('otto_language', lang); updateTranslations(lang); } function updateTranslations(lang) { const t = translations[lang] || translations['en-US']; document.querySelectorAll('[data-i18n]').forEach(el => { const key = el.getAttribute('data-i18n'); if (t[key]) { if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') { el.placeholder = t[key]; } else { el.textContent = t[key]; } } }); document.getElementById('language').value = lang; } const currentLang = getCurrentLanguage(); updateTranslations(currentLang); let qrStream = null; let qrVideo = null; let qrCanvas = null; let qrContext = null; let qrScanInterval = null; if (!window.jsQR) { const script = document.createElement('script'); script.src = 'https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js'; script.onload = function() { console.log('jsQR library loaded'); }; document.head.appendChild(script); } async function scanQRCode() { const scannerDiv = document.getElementById('qr-scanner'); if (scannerDiv) { scannerDiv.style.display = 'block'; } const statusDiv = document.getElementById('qr-status'); qrVideo = document.getElementById('qr-video'); qrCanvas = document.getElementById('qr-canvas'); if (!qrVideo || !qrCanvas) { alert('QR scanner elements not found'); return; } scannerDiv.style.display = 'block'; statusDiv.textContent = 'Requesting camera access...'; try { qrStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment', width: { ideal: 640 }, height: { ideal: 480 } } }); qrVideo.srcObject = qrStream; qrVideo.setAttribute('playsinline', true); qrVideo.play(); qrContext = qrCanvas.getContext('2d'); qrCanvas.width = qrVideo.videoWidth; qrCanvas.height = qrVideo.videoHeight; statusDiv.textContent = 'Point camera at QR code...'; qrScanInterval = setInterval(function() { if (qrVideo.readyState === qrVideo.HAVE_ENOUGH_DATA) { qrContext.drawImage(qrVideo, 0, 0, qrCanvas.width, qrCanvas.height); const imageData = qrContext.getImageData(0, 0, qrCanvas.width, qrCanvas.height); if (window.jsQR) { const code = jsQR(imageData.data, imageData.width, imageData.height); if (code) { statusDiv.textContent = 'QR code detected! Processing...'; clearInterval(qrScanInterval); stopQRScanner(); handleQRCodeResult(code.data); } } } }, 100); } catch (err) { console.error('Error accessing camera:', err); statusDiv.textContent = 'Error: ' + err.message; statusDiv.style.color = '#dc3545'; } } function stopQRScanner() { if (qrScanInterval) { clearInterval(qrScanInterval); qrScanInterval = null; } if (qrStream) { qrStream.getTracks().forEach(track => track.stop()); qrStream = null; } if (qrVideo) { qrVideo.srcObject = null; } document.getElementById('qr-scanner').style.display = 'none'; } async function handleQRCodeResult(qrData) { try { let deviceInfo; if (qrData.startsWith('{')) { deviceInfo = JSON.parse(qrData); } else { const url = qrData.startsWith('http') ? qrData : 'http://' + qrData; const response = await fetch(url + '/api/device/info'); deviceInfo = await response.json(); } if (deviceInfo.ip_address && deviceInfo.port) { saveDevice(deviceInfo); connectToDevice(deviceInfo); } else { alert('Invalid QR code: missing IP address or port'); } } catch (err) { console.error('Error processing QR code:', err); alert('Error processing QR code: ' + err.message); } } function saveDevice(deviceInfo) { const devices = getSavedDevices(); const deviceId = deviceInfo.device_id || deviceInfo.ip_address; const existingIndex = devices.findIndex(d => d.device_id === deviceId); const device = { device_id: deviceId, device_name: deviceInfo.device_name || 'Otto Robot', ip_address: deviceInfo.ip_address, port: deviceInfo.port || 80, last_connected: Date.now() }; if (existingIndex >= 0) { devices[existingIndex] = device; } else { devices.push(device); } localStorage.setItem('otto_saved_devices', JSON.stringify(devices)); } function getSavedDevices() { const saved = localStorage.getItem('otto_saved_devices'); return saved ? JSON.parse(saved) : []; } function removeDevice(deviceId) { const devices = getSavedDevices(); const filtered = devices.filter(d => d.device_id !== deviceId); localStorage.setItem('otto_saved_devices', JSON.stringify(filtered)); showSavedDevices(); } async function showSavedDevices() { const devicesListDiv = document.getElementById('saved-devices-list'); const containerDiv = document.getElementById('devices-container'); const qrScannerDiv = document.getElementById('qr-scanner'); if (qrScannerDiv && qrScannerDiv.style.display !== 'none') { stopQRScanner(); } if (devicesListDiv) { devicesListDiv.style.display = 'block'; } const devices = getSavedDevices(); if (devices.length === 0) { containerDiv.innerHTML = '<p style="text-align: center; color: #666;">No saved devices</p>'; devicesListDiv.style.display = 'block'; return; } containerDiv.innerHTML = ''; devices.forEach(device => { const deviceDiv = document.createElement('div'); deviceDiv.style.cssText = 'padding: 15px; margin: 10px 0; background: white; border-radius: 8px; border: 2px solid #e5e7eb; display: flex; justify-content: space-between; align-items: center;'; const infoDiv = document.createElement('div'); infoDiv.innerHTML = ` <div style="font-weight: bold; font-size: 16px; margin-bottom: 5px;">${device.device_name}</div> <div style="font-size: 14px; color: #666;">${device.ip_address}:${device.port}</div> <div style="font-size: 12px; color: #999;">Last connected: ${new Date(device.last_connected).toLocaleString()}</div> `; const buttonDiv = document.createElement('div'); buttonDiv.style.cssText = 'display: flex; gap: 10px;'; const connectBtn = document.createElement('button'); connectBtn.className = 'btn'; connectBtn.textContent = 'Connect'; connectBtn.style.cssText = 'padding: 8px 16px; font-size: 14px; background: #059669;'; connectBtn.onclick = () => connectToDevice(device); const removeBtn = document.createElement('button'); removeBtn.className = 'btn'; removeBtn.textContent = 'Remove'; removeBtn.style.cssText = 'padding: 8px 16px; font-size: 14px; background: #dc3545;'; removeBtn.onclick = () => removeDevice(device.device_id); buttonDiv.appendChild(connectBtn); buttonDiv.appendChild(removeBtn); deviceDiv.appendChild(infoDiv); deviceDiv.appendChild(buttonDiv); containerDiv.appendChild(deviceDiv); }); devicesListDiv.style.display = 'block'; } async function connectToDevice(deviceInfo) { const ip = deviceInfo.ip_address; const port = deviceInfo.port || 80; const url = `http://${ip}:${port}/otto`; try { const response = await fetch(`http://${ip}:${port}/api/device/info`, { method: 'GET', timeout: 3000 }); if (response.ok) { saveDevice(deviceInfo); window.location.href = url; } else { alert('Device is offline or unreachable'); } } catch (err) { alert('Error connecting to device: ' + err.message); } } async function showQrCodeOnLCD() { try { const res = await fetch('/api/device/show-qr', { method: 'POST', headers: { 'Content-Type': 'application/json' } }); if (!res.ok) { console.error('Failed to show QR code, status:', res.status); return; } let data; try { const text = await res.text(); data = JSON.parse(text); } catch (parseError) { console.error('Failed to parse JSON response:', parseError); console.error('Response text:', await res.text()); return; } if (data.success) { console.log('QR code displayed on LCD:', data.qr_data); } else { console.error('Error showing QR code:', data.error || 'Failed to show QR code'); } } catch (e) { console.error('Error showing QR code:', e.message); } } window.addEventListener('load', function() { initMobileUI(); showQrCodeOnLCD(); const devices = getSavedDevices(); if (devices.length > 0) { const lastDevice = devices.sort((a, b) => b.last_connected - a.last_connected)[0]; const currentHost = window.location.hostname; if (currentHost !== lastDevice.ip_address) { } } }); let recognition = null; let isRecording = false; const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; const isSpeechSupported = !!SpeechRecognition; if (isSpeechSupported) { recognition = new SpeechRecognition(); recognition.continuous = false; recognition.interimResults = false; recognition.lang = getCurrentLanguage(); recognition.onstart = function() { isRecording = true; updateVoiceButton(true); const statusEl = document.getElementById('voice-status'); if (statusEl) { statusEl.style.display = 'block'; statusEl.className = 'recording'; const lang = getCurrentLanguage(); const t = translations[lang] || translations['en-US']; statusEl.textContent = t['otto.voice_status_recording'] || 'üé§ Recording... Speak now!'; } const menuVoiceText = document.getElementById('menu-voice-text'); if (menuVoiceText) { const lang = getCurrentLanguage(); const t = translations[lang] || translations['en-US']; menuVoiceText.textContent = t['otto.voice_stop'] || '‚èπÔ∏è Stop Recording'; } }; recognition.onresult = function(event) { const transcript = event.results[0][0].transcript; const textEl = document.getElementById('voice-text'); if (textEl) { textEl.style.display = 'block'; textEl.textContent = transcript; } sendVoiceCommandToAI(transcript); }; recognition.onerror = function(event) { console.error('Speech recognition error:', event.error); isRecording = false; updateVoiceButton(false); const statusEl = document.getElementById('voice-status'); if (statusEl) { statusEl.className = ''; statusEl.textContent = '‚ùå Error: ' + event.error; setTimeout(() => { statusEl.style.display = 'none'; }, 3000); } }; recognition.onend = function() { isRecording = false; updateVoiceButton(false); const statusEl = document.getElementById('voice-status'); if (statusEl && statusEl.className === 'recording') { statusEl.className = ''; statusEl.textContent = ''; statusEl.style.display = 'none'; } }; } function toggleVoiceControl() { if (!isSpeechSupported) { alert('Your browser does not support speech recognition. Please use Chrome, Edge, or Safari.'); return; } if (isRecording) { recognition.stop(); } else { try { recognition.lang = getCurrentLanguage(); recognition.start(); } catch (e) { console.error('Failed to start recognition:', e); alert('Failed to start voice recognition. Please check microphone permissions.'); } } } function updateVoiceButton(recording) { const btn = document.getElementById('voice-btn'); const lang = getCurrentLanguage(); const t = translations[lang] || translations['en-US']; if (recording) { btn.classList.add('voice-recording'); btn.textContent = t['otto.voice_stop'] || '‚èπÔ∏è Stop Recording'; } else { btn.classList.remove('voice-recording'); btn.textContent = t['otto.voice_start'] || 'üé§ Start Voice Control'; } } async function sendVoiceCommandToAI(text) { const statusEl = document.getElementById('voice-status'); if (statusEl) { statusEl.style.display = 'block'; statusEl.className = 'processing'; const lang = getCurrentLanguage(); const t = translations[lang] || translations['en-US']; statusEl.textContent = t['otto.voice_status_processing'] || 'ü§î Processing... Sending to AI...'; } try { const res = await fetch('/api/ai/send', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text: text }) }); const data = await res.json(); if (data.success && statusEl) { statusEl.className = ''; const lang = getCurrentLanguage(); const t = translations[lang] || translations['en-US']; statusEl.textContent = t['otto.voice_status_sent'] || '‚úÖ Command sent! AI is processing...'; setTimeout(() => { if (statusEl) { statusEl.textContent = ''; statusEl.style.display = 'none'; } updateStatus(); }, 3000); } else { statusEl.className = ''; statusEl.textContent = '‚ùå Error: ' + (data.message || 'Failed to send command'); } } catch (e) { statusEl.className = ''; statusEl.textContent = '‚ùå Error: ' + e.message; } } let forceAiBusy = false; function notifyStatus(message, isError) { if (typeof showStatus === 'function') { showStatus(message, !!isError); } else { if (isError) { console.error(message); alert(message); } else { console.log(message); } } } let volumeUpdateTimer = null; function updateVolumeDisplay(value) { const label = document.getElementById('volume-value'); if (label) { label.textContent = Math.round(value) + '%'; } } function handleVolumeInput(value) { updateVolumeDisplay(value); if (volumeUpdateTimer) { clearTimeout(volumeUpdateTimer); } volumeUpdateTimer = setTimeout(() => { setDeviceVolume(value); }, 200); } async function setDeviceVolume(value) { const volume = parseInt(value, 10); if (isNaN(volume)) { return; } try { const res = await fetch('/api/audio/volume', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ volume }) }); if (!res.ok) { throw new Error('status ' + res.status); } const data = await res.json(); if (!data.success) { throw new Error(data.message || 'Failed to update volume'); } } catch (err) { console.error('setDeviceVolume error', err); notifyStatus('Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t √¢m l∆∞·ª£ng: ' + err.message, true); } } async function loadVolumeLevel() { try { const res = await fetch('/api/audio/volume'); if (!res.ok) { throw new Error('status ' + res.status); } const data = await res.json(); if (typeof data.volume === 'number') { const slider = document.getElementById('volume-slider'); if (slider) { slider.value = data.volume; updateVolumeDisplay(data.volume); } } } catch (err) { console.warn('Failed to load volume level', err); } } document.addEventListener('DOMContentLoaded', loadVolumeLevel); async function forceAiStart() { if (forceAiBusy) { notifyStatus('ƒêang k√≠ch ho·∫°t AI...', false); return; } forceAiBusy = true; notifyStatus('ƒêang k√≠ch ho·∫°t AI...', false); try { const res = await fetch('/api/device/wake', { method: 'POST' }); if (!res.ok) { throw new Error('status ' + res.status); } await res.json().catch(() => ({})); notifyStatus('AI ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t!', false); } catch (err) { console.error('forceAiStart error', err); notifyStatus('Kh√¥ng th·ªÉ k√≠ch ho·∫°t AI: ' + err.message, true); } finally { setTimeout(() => { forceAiBusy = false; }, 2000); const panel = document.getElementById('menu-panel'); if (panel) { panel.classList.remove('show'); } } } function toggleMenu() { const panel = document.getElementById('menu-panel'); if (panel) { panel.classList.toggle('show'); } } document.addEventListener('click', function(event) { const menuButton = document.querySelector('.menu-button'); const menuPanel = document.getElementById('menu-panel'); if (menuPanel && menuButton && !menuPanel.contains(event.target) && !menuButton.contains(event.target)) { menuPanel.classList.remove('show'); } }); function toggleSection(element) { const content = element.nextElementSibling; if (content && content.classList.contains('collapsible-content')) { element.classList.toggle('collapsed'); content.classList.toggle('collapsed'); } } function initMobileUI() { if (window.innerWidth <= 768) { const collapsibles = document.querySelectorAll('.collapsible'); collapsibles.forEach(el => { if (!el.closest('.control-section').querySelector('.direction-grid')) { el.classList.add('collapsed'); const content = el.nextElementSibling; if (content && content.classList.contains('collapsible-content')) { content.classList.add('collapsed'); } } }); } } window.addEventListener('resize', function() { if (window.innerWidth > 768) { const collapsibles = document.querySelectorAll('.collapsible'); collapsibles.forEach(el => { el.classList.remove('collapsed'); const content = el.nextElementSibling; if (content && content.classList.contains('collapsible-content')) { content.classList.remove('collapsed'); } }); } }); function sendCommand(command) { if (navigator.vibrate) { navigator.vibrate(50); } fetch('/api/otto/command', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ command: command }) }) .then(r => r.json()) .then(d => { if (d.success) { updateStatus(); } else { alert('Error: ' + (d.error || 'Unknown error')); } }) .catch(e => alert('Error: ' + e)); } function setEmoji(emotion) { fetch('/api/otto/emoji', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ emotion: emotion }) }) .then(r => r.json()) .then(d => { if (!d.success) { alert('Error: ' + (d.error || 'Unknown error')); } }) .catch(e => alert('Error: ' + e)); } function updateStatus() { fetch('/api/otto/status') .then(r => r.json()) .then(d => { const statusEl = document.getElementById('status'); const lang = getCurrentLanguage(); const t = translations[lang] || translations['en-US']; const statusText = t['otto.status.' + d.status] || ('Status: ' + d.status); statusEl.textContent = statusText; statusEl.className = 'status ' + d.status; }) .catch(e => console.error('Status error:', e)); } setInterval(updateStatus, 500); updateStatus(); if ('serviceWorker' in navigator) { window.addEventListener('load', function() { navigator.serviceWorker.register('/service-worker.js') .then(function(registration) { console.log('ServiceWorker registration successful with scope: ', registration.scope); }) .catch(function(err) { console.log('ServiceWorker registration failed: ', err); }); }); } let deferredPrompt = null; let pwaBanner = null; let pwaInstallBtn = null; function initPWA() { pwaBanner = document.getElementById('pwa-install-banner'); pwaInstallBtn = document.getElementById('pwa-install-btn'); if (!pwaBanner) { console.warn('PWA banner element not found'); return; } console.log('PWA banner initialized'); if (isPWAInstalled()) { console.log('PWA already installed, hiding banner'); pwaBanner.style.display = 'none'; return; } if (wasBannerDismissed()) { console.log('PWA banner was dismissed, hiding'); pwaBanner.style.display = 'none'; return; } setTimeout(function() { if (pwaBanner && !isPWAInstalled() && !wasBannerDismissed()) { console.log('Showing PWA install banner'); pwaBanner.style.display = 'block'; } }, 1000); } function isPWAInstalled() { return window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true || document.referrer.includes('android-app://') function wasBannerDismissed() { return localStorage.getItem('pwa-banner-dismissed') === 'true'; } function showPWAInstallBanner() { if (!pwaBanner) { pwaBanner = document.getElementById('pwa-install-banner'); } if (isPWAInstalled() || wasBannerDismissed()) { return; } if (pwaBanner) { console.log('Force showing PWA banner'); pwaBanner.style.display = 'block'; } } function installPWA() { console.log('installPWA called, deferredPrompt:', deferredPrompt ? 'available' : 'null'); if (deferredPrompt) { console.log('Triggering browser install prompt - dialog s·∫Ω xu·∫•t hi·ªán'); try { deferredPrompt.prompt(); deferredPrompt.userChoice.then(function(choiceResult) { console.log('User choice from browser prompt:', choiceResult.outcome); if (choiceResult.outcome === 'accepted') { console.log('User accepted - browser will install app automatically'); if (pwaBanner) { pwaBanner.style.display = 'none'; } localStorage.setItem('pwa-banner-dismissed', 'true'); } else { console.log('User dismissed the install prompt'); } deferredPrompt = null; }).catch(function(err) { console.error('Error in userChoice promise:', err); deferredPrompt = null; }); } catch (err) { console.error('Error calling prompt():', err); alert('L·ªói khi m·ªü dialog c√†i ƒë·∫∑t. Vui l√≤ng c√†i ƒë·∫∑t th·ªß c√¥ng t·ª´ menu browser (‚ãÆ ‚Üí Install app).'); } } else { console.log('No deferredPrompt - browser may not support automatic install prompt'); if (/Android/.test(navigator.userAgent) && /Chrome/.test(navigator.userAgent)) { alert('ƒê·ªÉ c√†i ƒë·∫∑t ·ª©ng d·ª•ng tr√™n Android/Chrome:\n\n' + '1. Nh·∫•n menu (3 ch·∫•m ‚ãÆ) ·ªü g√≥c tr√™n b√™n ph·∫£i\n' + '2. Ch·ªçn "C√†i ƒë·∫∑t" ho·∫∑c "Install app"\n' + '3. Nh·∫•n "C√†i ƒë·∫∑t" trong dialog'); } else if (/iPhone|iPad|iPod/.test(navigator.userAgent)) { alert('ƒê·ªÉ c√†i ƒë·∫∑t tr√™n iOS:\n\n' + '1. Nh·∫•n n√∫t Share (m≈©i t√™n l√™n)\n' + '2. Cu·ªôn xu·ªëng v√† ch·ªçn "Add to Home Screen"\n' + '3. Nh·∫•n "Add"'); } else { alert('ƒê·ªÉ c√†i ƒë·∫∑t ·ª©ng d·ª•ng:\n\n' + 'üì± Android/Chrome: Nh·∫•n menu (‚ãÆ) ‚Üí "Install app"\n' + 'üíª Desktop: Nh·∫•n bi·ªÉu t∆∞·ª£ng (+) tr√™n thanh ƒë·ªãa ch·ªâ'); } } } function dismissPWA() { if (pwaBanner) { pwaBanner.style.display = 'none'; } localStorage.setItem('pwa-banner-dismissed', 'true'); console.log('PWA banner dismissed'); } window.addEventListener('beforeinstallprompt', function(e) { console.log('beforeinstallprompt event fired - browser supports automatic install'); e.preventDefault(); deferredPrompt = e; if (pwaInstallBtn) { pwaInstallBtn.textContent = 'C√†i ƒë·∫∑t ngay'; } showPWAInstallBanner(); }); window.addEventListener('appinstalled', function(evt) { console.log('PWA app was installed successfully by browser'); if (pwaBanner) { pwaBanner.style.display = 'none'; } localStorage.setItem('pwa-banner-dismissed', 'true'); }); if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initPWA); } else { initPWA(); } setTimeout(function() { if (!isPWAInstalled() && !wasBannerDismissed()) { console.log('Fallback: showing banner after 2 seconds'); showPWAInstallBanner(); } else { console.log('Banner not shown - installed:', isPWAInstalled(), 'dismissed:', wasBannerDismissed()); } }, 2000); console.log('PWA Status - Installed:', isPWAInstalled(), 'Dismissed:', wasBannerDismissed());