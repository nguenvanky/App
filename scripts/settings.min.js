function showStatus(message, isError) { const status = document.getElementById('status'); status.className = 'status ' + (isError ? 'error' : 'success'); status.textContent = message; setTimeout(() => status.textContent = '', 3000); } function showAddAlarm() { document.getElementById('add-alarm-form').style.display = 'block'; } function hideAddAlarm() { document.getElementById('add-alarm-form').style.display = 'none'; } const settingsTranslations = { 'zh-CN': { 'settings.title': '‚öôÔ∏è Â∞èÊô∫ËÆæÁΩÆ' }, 'zh-TW': { 'settings.title': '‚öôÔ∏è Â∞èÊô∫Ë®≠ÂÆö' }, 'en-US': { 'settings.title': '‚öôÔ∏è Xiaozhi Settings' }, 'vi-VN': { 'settings.title': '‚öôÔ∏è C√†i ƒê·∫∑t Xiaozhi' } }; function getCurrentLanguage() { const saved = localStorage.getItem('web_settings_language'); if (saved && settingsTranslations[saved]) return saved; const browserLang = navigator.language || navigator.userLanguage; if (browserLang.startsWith('zh')) { return browserLang === 'zh-TW' || browserLang === 'zh-Hant' ? 'zh-TW' : 'zh-CN'; } if (settingsTranslations[browserLang]) return browserLang; return 'en-US'; } function changeLanguage(lang) { localStorage.setItem('web_settings_language', lang); updateTranslations(lang); } function updateTranslations(lang) { const t = settingsTranslations[lang] || settingsTranslations['en-US']; document.querySelectorAll('[data-i18n]').forEach(el => { const key = el.getAttribute('data-i18n'); if (t[key]) { if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') { el.placeholder = t[key]; } else { el.textContent = t[key]; } } }); const langSelect = document.getElementById('language'); if (langSelect) { langSelect.value = lang; } } const currentLang = getCurrentLanguage(); updateTranslations(currentLang); let qrCodes = []; let portalMusicServers = []; let portalConfig = null; let portalMusicStatusEl = null; let portalMusicListEl = null; let deviceMacAddress = null; let portalMusicFetchRequested = false; let portalRadioChannels = []; let portalRadioStatusEl = null; let portalRadioListEl = null; let portalRadioFetchRequested = false; let portalFirmwareList = []; let portalOtaStatusEl = null; let portalOtaListEl = null; let portalOtaFetchRequested = false; let portalAssetsList = []; let portalAssetsStatusEl = null; let portalAssetsListEl = null; let portalAssetsFetchRequested = false; const MAX_QR_CODES = 10; async function loadQrSettings() { try { const res = await fetch('/api/qr/settings'); if (!res.ok) { console.error('Failed to load QR settings, status:', res.status); document.getElementById('qr_duration').value = 40; qrCodes = []; renderQrCodesList(); return; } let data; try { const text = await res.text(); data = JSON.parse(text); } catch (parseError) { console.error('Failed to parse JSON response:', parseError); document.getElementById('qr_duration').value = 40; qrCodes = []; renderQrCodesList(); return; } if (data.success) { document.getElementById('qr_duration').value = data.duration || 40; qrCodes = data.qr_codes || []; renderQrCodesList(); } } catch (e) { console.error('Error loading QR settings:', e); document.getElementById('qr_duration').value = 40; qrCodes = []; renderQrCodesList(); } } function renderQrCodesList() { const listDiv = document.getElementById('qr-codes-list'); listDiv.innerHTML = ''; if (qrCodes.length === 0) { listDiv.innerHTML = '<p style="color: #666; font-style: italic;">No QR codes yet. Add your first QR code!</p>'; return; } qrCodes.forEach((qr, index) => { const qrDiv = document.createElement('div'); qrDiv.style.cssText = 'border: 1px solid #ddd; padding: 10px; margin: 5px 0; border-radius: 4px; background: #f9f9f9;'; qrDiv.innerHTML = ` <div style="display: flex; justify-content: space-between; align-items: start;"> <div style="flex: 1;"> <strong>${escapeHtml(qr.name)}</strong> <div style="font-size: 12px; color: #666; margin-top: 5px; word-break: break-all;"> ${escapeHtml(qr.data.substring(0, 80))}${qr.data.length > 80 ? '...' : ''} </div> </div> <div> <button onclick="displayQrCode(${index})" style="padding: 5px 10px; margin: 0 2px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;">üì∫ Show</button> <button onclick="editQrCode(${index})" style="padding: 5px 10px; margin: 0 2px; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer;">‚úèÔ∏è Edit</button> <button onclick="deleteQrCode(${index})" style="padding: 5px 10px; margin: 0 2px; background: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer;">üóëÔ∏è Delete</button> </div> </div> `; listDiv.appendChild(qrDiv); }); } function showAddQrCode() { document.getElementById('add-qr-form').style.display = 'block'; document.getElementById('new_qr_name').value = ''; document.getElementById('new_qr_data').value = ''; } function hideAddQrCode() { document.getElementById('add-qr-form').style.display = 'none'; } function addQrCode() { const name = document.getElementById('new_qr_name').value.trim(); const data = document.getElementById('new_qr_data').value.trim(); if (!name || !data) { alert('Please enter both name and QR data'); return; } if (qrCodes.length >= MAX_QR_CODES) { alert(`Maximum ${MAX_QR_CODES} QR codes allowed`); return; } qrCodes.push({ id: Date.now().toString(), name: name, data: data }); renderQrCodesList(); hideAddQrCode(); } function editQrCode(index) { const qr = qrCodes[index]; document.getElementById('new_qr_name').value = qr.name; document.getElementById('new_qr_data').value = qr.data; document.getElementById('add-qr-form').style.display = 'block'; const addBtn = document.querySelector('#add-qr-form button[onclick="addQrCode()"]'); addBtn.textContent = 'Update'; addBtn.onclick = function() { updateQrCode(index); }; } function updateQrCode(index) { const name = document.getElementById('new_qr_name').value.trim(); const data = document.getElementById('new_qr_data').value.trim(); if (!name || !data) { alert('Please enter both name and QR data'); return; } qrCodes[index].name = name; qrCodes[index].data = data; renderQrCodesList(); hideAddQrCode(); const addBtn = document.querySelector('#add-qr-form button[onclick*="QrCode"]'); addBtn.textContent = 'Add'; addBtn.onclick = addQrCode; } function deleteQrCode(index) { if (confirm('Delete this QR code?')) { qrCodes.splice(index, 1); renderQrCodesList(); } } async function displayQrCode(index) { const qr = qrCodes[index]; try { const res = await fetch('/api/qr/display', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ qr_data: qr.data }) }); if (!res.ok) { const text = await res.text(); alert('Failed to display QR code, status: ' + res.status + ' - ' + text); return; } let data; try { const text = await res.text(); data = JSON.parse(text); } catch (parseError) { console.error('Failed to parse JSON response:', parseError); alert('Failed to parse server response'); return; } if (data.success) { alert('QR code displayed on LCD!'); } else { alert('Failed: ' + (data.error || 'Unknown error')); } } catch (e) { console.error('Error displaying QR code:', e); alert('Error: ' + e.message); } } async function saveQrSettings() { const duration = parseInt(document.getElementById('qr_duration').value); if (duration < 10 || duration > 120) { alert('Duration must be between 10 and 120 seconds'); return; } try { const res = await fetch('/api/qr/settings', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ duration: duration, qr_codes: qrCodes }) }); if (!res.ok) { const text = await res.text(); showStatus('Failed to save QR settings, status: ' + res.status + ' - ' + text, true); return; } let data; try { const text = await res.text(); data = JSON.parse(text); } catch (parseError) { console.error('Failed to parse JSON response:', parseError); showStatus('Failed to parse server response', true); return; } if (data.success) { showStatus('QR settings saved!', false); } else { showStatus('Failed: ' + (data.error || 'Unknown error'), true); } } catch (e) { console.error('Error saving QR settings:', e); showStatus('Error: ' + e.message, true); } } function ensurePortalElements() { if (!portalMusicStatusEl) { portalMusicStatusEl = document.getElementById('portal-music-status'); } if (!portalMusicListEl) { portalMusicListEl = document.getElementById('portal-music-list'); } return portalMusicStatusEl !== null && portalMusicListEl !== null; } function setPortalMusicStatus(message, isError = false) { if (!ensurePortalElements()) return; portalMusicStatusEl.textContent = message; if (isError) { portalMusicStatusEl.classList.add('error'); } else { portalMusicStatusEl.classList.remove('error'); } } function renderPortalMusicServers(servers) { if (!ensurePortalElements()) return; portalMusicListEl.innerHTML = ''; servers.forEach(server => { const endpoint = server.endpoint || server.url || server.api || ''; if (!endpoint) { return; } const item = document.createElement('div'); item.className = 'portal-music-item'; const meta = document.createElement('div'); meta.className = 'portal-music-meta'; const name = document.createElement('strong'); name.textContent = server.name || server.title || 'M√°y ch·ªß kh√¥ng t√™n'; meta.appendChild(name); const detail = document.createElement('span'); const region = server.region ? `‚Ä¢ ${server.region}` : ''; const priority = typeof server.priority === 'number' ? `‚Ä¢ ∆Øu ti√™n ${server.priority}` : ''; detail.textContent = `${server.status === 'online' ? 'üü¢ Online' : '‚ÑπÔ∏è' } ${region} ${priority}`.trim(); meta.appendChild(detail); const urlLine = document.createElement('span'); urlLine.style.fontSize = '12px'; urlLine.style.color = '#4a5568'; urlLine.textContent = endpoint; meta.appendChild(urlLine); const btn = document.createElement('button'); btn.className = 'portal-music-select'; btn.textContent = 'Ch·ªçn m√°y ch·ªß'; btn.onclick = function() { selectPortalMusicServer(endpoint, server.name || server.title || ''); }; item.appendChild(meta); item.appendChild(btn); portalMusicListEl.appendChild(item); }); } function selectPortalMusicServer(endpoint, label) { const input = document.getElementById('music_server_url'); if (input) { input.value = endpoint; input.focus(); } showStatus(`ƒê√£ ch·ªçn m√°y ch·ªß: ${label || endpoint}`, false); } let vs=false; async function checkVipStatus(){try{const r=await fetch('/api/vip/check');if(!r.ok)return;const d=await r.json();vs=d.vip_status||false;const vc=d.vip_checked||false;updateVipLinks();if(!vc&&portalConfig?.portal_base_url&&deviceMacAddress){setTimeout(()=>checkVipFromPortal(),500);}}catch(e){}} async function checkVipFromPortal(){if(!portalConfig?.portal_base_url||!deviceMacAddress){return;}try{const url=portalConfig.portal_base_url+'index.php?api=check_vip&token='+encodeURIComponent(deviceMacAddress);const r=await fetch(url);if(!r.ok){return;}const txt=await r.text();let d;try{d=JSON.parse(txt);}catch(e){return;}const isVip=d.is_vip===true;await updateVipStatus(isVip);}catch(e){}} async function updateVipStatus(v){try{const r=await fetch('/api/vip/update',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({vip_status:v})});if(!r.ok)return;const d=await r.json();vs=d.vip_status||false;updateVipLinks();}catch(e){}} function updateVipLinks(){const ol=document.querySelector('a[href="/otto"]'),sl=document.querySelector('a[href="/servo-calibration"]');const s=vs?'1':'0.5',p=vs?'auto':'none',c=vs?'pointer':'not-allowed';if(ol){ol.style.opacity=s;ol.style.pointerEvents=p;ol.style.cursor=c;if(!vs)ol.title='VIP Required';}if(sl){sl.style.opacity=s;sl.style.pointerEvents=p;sl.style.cursor=c;if(!vs)sl.title='VIP Required';}} async function fetchPortalConfig() { if (!ensurePortalElements()) return; try { const res = await fetch('/portal-config.json'); if (!res.ok) { throw new Error('HTTP ' + res.status); } portalConfig = await res.json(); vs = portalConfig.vip_status || false; const vc = portalConfig.vip_checked || false; updateVipLinks(); if (!vc && deviceMacAddress) setTimeout(()=>checkVipFromPortal(),1000); setPortalMusicStatus('üîê ƒêang x√°c minh thi·∫øt b·ªã v·ªõi h·ªá th·ªëng qu·∫£n l√Ω...'); tryFetchPortalMusicServers(true); if (ensureRadioPortalElements()) { setPortalRadioStatus('üîê ƒêang x√°c minh thi·∫øt b·ªã v·ªõi h·ªá th·ªëng qu·∫£n l√Ω...'); tryFetchPortalRadioChannels(true); } if (ensureOtaPortalElements()) { setPortalOtaStatus('üîê ƒêang x√°c minh thi·∫øt b·ªã v·ªõi h·ªá th·ªëng qu·∫£n l√Ω...'); tryFetchPortalFirmwareList(true); } if (ensureAssetsPortalElements()) { setPortalAssetsStatus('üîê ƒêang x√°c minh thi·∫øt b·ªã v·ªõi h·ªá th·ªëng qu·∫£n l√Ω...'); tryFetchPortalAssetsList(true); } } catch (error) { console.error('Portal config error', error); setPortalMusicStatus('Kh√¥ng th·ªÉ t·∫£i c·∫•u h√¨nh portal. Vui l√≤ng ki·ªÉm tra l·∫°i.', true); if (ensureRadioPortalElements()) { setPortalRadioStatus('Kh√¥ng th·ªÉ t·∫£i c·∫•u h√¨nh portal. Vui l√≤ng ki·ªÉm tra l·∫°i.', true); } if (ensureOtaPortalElements()) { setPortalOtaStatus('Kh√¥ng th·ªÉ t·∫£i c·∫•u h√¨nh portal. Vui l√≤ng ki·ªÉm tra l·∫°i.', true); } if (ensureAssetsPortalElements()) { setPortalAssetsStatus('Kh√¥ng th·ªÉ t·∫£i c·∫•u h√¨nh portal. Vui l√≤ng ki·ªÉm tra l·∫°i.', true); } } } async function tryFetchPortalMusicServers(force = false) { if (!ensurePortalElements()) return; if (!portalConfig || !deviceMacAddress) return; if (portalMusicFetchRequested && !force) return; portalMusicFetchRequested = true; await loadPortalMusicServers(); } function buildPortalMusicEndpoint() { if (!portalConfig) return null; const base = portalConfig.music_servers_endpoint || (portalConfig.portal_base_url ? portalConfig.portal_base_url + 'index.php?api=music_servers' : null); if (!base) return null; const separator = base.includes('?') ? '&' : '?'; return `${base}${separator}token=${encodeURIComponent(deviceMacAddress)}`; } async function loadPortalMusicServers() { if (!ensurePortalElements()) return; const endpoint = buildPortalMusicEndpoint(); if (!endpoint) { setPortalMusicStatus('Thi·∫øu c·∫•u h√¨nh endpoint m√°y ch·ªß nh·∫°c.', true); return; } setPortalMusicStatus('üîÑ ƒêang t·∫£i danh s√°ch m√°y ch·ªß VIP t·ª´ portal...'); try { const response = await fetch(endpoint); if (!response.ok) { throw new Error('HTTP ' + response.status); } const data = await response.json(); if (data.vip_required) { setPortalMusicStatus('Thi·∫øt b·ªã ch∆∞a ƒë∆∞·ª£c k√≠ch ho·∫°t VIP. Vui l√≤ng ƒëƒÉng k√Ω tr√™n portal.', true); portalMusicListEl.innerHTML = ''; return; } const servers = Array.isArray(data.servers) ? data.servers : (Array.isArray(data.list) ? data.list : []); if (!servers.length) { setPortalMusicStatus('Kh√¥ng t√¨m th·∫•y m√°y ch·ªß VIP n√†o cho thi·∫øt b·ªã n√†y.', true); portalMusicListEl.innerHTML = ''; return; } portalMusicServers = servers; renderPortalMusicServers(servers); setPortalMusicStatus('Ch·ªçn m·ªôt m√°y ch·ªß VIP b√™n d∆∞·ªõi ƒë·ªÉ √°p d·ª•ng nhanh.'); } catch (error) { console.error('Portal music fetch error', error); setPortalMusicStatus('Kh√¥ng th·ªÉ k·∫øt n·ªëi portal. Ki·ªÉm tra m·∫°ng ho·∫∑c tr·∫°ng th√°i VIP.', true); portalMusicListEl.innerHTML = ''; } } function initPortalMusicSection() { if (!ensurePortalElements()) return; fetchPortalConfig(); } if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initPortalMusicSection); } else { initPortalMusicSection(); } function ensureRadioPortalElements() { if (!portalRadioStatusEl) { portalRadioStatusEl = document.getElementById('portal-radio-status'); } if (!portalRadioListEl) { portalRadioListEl = document.getElementById('portal-radio-list'); } return portalRadioStatusEl !== null && portalRadioListEl !== null; } function setPortalRadioStatus(message, isError = false) { if (!ensureRadioPortalElements()) return; portalRadioStatusEl.textContent = message; if (isError) { portalRadioStatusEl.classList.add('error'); } else { portalRadioStatusEl.classList.remove('error'); } } function renderPortalRadioChannels(channels) { if (!ensureRadioPortalElements()) return; portalRadioListEl.innerHTML = ''; channels.forEach(channel => { const url = channel.url || channel.stream_url || ''; const title = channel.title || channel.name || 'K√™nh kh√¥ng t√™n'; const artist = channel.artist || ''; if (!url) { return; } const item = document.createElement('div'); item.className = 'portal-radio-item'; const meta = document.createElement('div'); meta.className = 'portal-radio-meta'; const name = document.createElement('strong'); name.textContent = title; meta.appendChild(name); const detail = document.createElement('span'); const genre = channel.genre ? `‚Ä¢ ${channel.genre}` : ''; const language = channel.language ? `‚Ä¢ ${channel.language.toUpperCase()}` : ''; const status = channel.status === 'online' ? 'üü¢ Online' : '‚ÑπÔ∏è'; detail.textContent = `${status} ${genre} ${language}`.trim(); meta.appendChild(detail); const urlLine = document.createElement('span'); urlLine.style.fontSize = '12px'; urlLine.style.color = '#4a5568'; urlLine.textContent = url; meta.appendChild(urlLine); const btn = document.createElement('button'); btn.className = 'portal-radio-select'; btn.textContent = 'Th√™m k√™nh'; btn.onclick = function() { selectPortalRadioChannel(title, url, artist); }; item.appendChild(meta); item.appendChild(btn); portalRadioListEl.appendChild(item); }); } function selectPortalRadioChannel(title, url, artist) { document.getElementById('new_radio_title').value = title; document.getElementById('new_radio_url').value = url; document.getElementById('new_radio_artist').value = artist || ''; document.getElementById('add-radio-form').style.display = 'block'; showStatus(`ƒê√£ ch·ªçn k√™nh: ${title}`, false); } function buildPortalRadioEndpoint() { if (!portalConfig) return null; const base = portalConfig.radio_channels_endpoint || (portalConfig.portal_base_url ? portalConfig.portal_base_url + 'index.php?api=radio_channels' : null); if (!base) return null; const separator = base.includes('?') ? '&' : '?'; return `${base}${separator}token=${encodeURIComponent(deviceMacAddress)}&output=esp32`; } async function loadPortalRadioChannels() { if (!ensureRadioPortalElements()) return; const endpoint = buildPortalRadioEndpoint(); if (!endpoint) { setPortalRadioStatus('Thi·∫øu c·∫•u h√¨nh endpoint k√™nh radio.', true); return; } setPortalRadioStatus('üîÑ ƒêang t·∫£i danh s√°ch k√™nh radio VIP t·ª´ portal...'); try { const response = await fetch(endpoint); if (!response.ok) { throw new Error('HTTP ' + response.status); } const data = await response.json(); let channels = []; if (Array.isArray(data)) { channels = data; } else if (data.vip_required) { setPortalRadioStatus('Thi·∫øt b·ªã ch∆∞a ƒë∆∞·ª£c k√≠ch ho·∫°t VIP. Vui l√≤ng ƒëƒÉng k√Ω tr√™n portal.', true); portalRadioListEl.innerHTML = ''; return; } else if (Array.isArray(data.channels)) { channels = data.channels; } else if (Array.isArray(data.list)) { channels = data.list; } if (!channels.length) { setPortalRadioStatus('Kh√¥ng t√¨m th·∫•y k√™nh radio VIP n√†o cho thi·∫øt b·ªã n√†y.', true); portalRadioListEl.innerHTML = ''; return; } portalRadioChannels = channels; renderPortalRadioChannels(channels); setPortalRadioStatus('Ch·ªçn m·ªôt k√™nh radio VIP b√™n d∆∞·ªõi ƒë·ªÉ th√™m v√†o danh s√°ch.'); } catch (error) { console.error('Portal radio fetch error', error); setPortalRadioStatus('Kh√¥ng th·ªÉ k·∫øt n·ªëi portal. Ki·ªÉm tra m·∫°ng ho·∫∑c tr·∫°ng th√°i VIP.', true); portalRadioListEl.innerHTML = ''; } } async function tryFetchPortalRadioChannels(force = false) { if (!ensureRadioPortalElements()) return; if (!portalConfig || !deviceMacAddress) return; if (portalRadioFetchRequested && !force) return; portalRadioFetchRequested = true; await loadPortalRadioChannels(); } function initPortalRadioSection() { if (!ensureRadioPortalElements()) return; if (portalConfig && deviceMacAddress) { tryFetchPortalRadioChannels(); } else { fetchPortalConfig().then(() => { if (deviceMacAddress) { tryFetchPortalRadioChannels(); } }); } } if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', function() { setTimeout(initPortalRadioSection, 1000); }); } else { setTimeout(initPortalRadioSection, 1000); } function ensureOtaPortalElements() { if (!portalOtaStatusEl) { portalOtaStatusEl = document.getElementById('portal-ota-status'); } if (!portalOtaListEl) { portalOtaListEl = document.getElementById('portal-ota-list'); } return portalOtaStatusEl !== null && portalOtaListEl !== null; } function setPortalOtaStatus(message, isError = false) { if (!ensureOtaPortalElements()) return; portalOtaStatusEl.textContent = message; if (isError) { portalOtaStatusEl.classList.add('error'); } else { portalOtaStatusEl.classList.remove('error'); } } function renderPortalFirmwareList(firmwareList) { if (!ensureOtaPortalElements()) return; portalOtaListEl.innerHTML = ''; firmwareList.forEach(firmware => { const url = firmware.file_url || firmware.url || firmware.download_url || firmware.link || ''; const version = firmware.version || firmware.name || 'Firmware kh√¥ng t√™n'; const description = firmware.release_notes || firmware.description || firmware.info || firmware.desc || ''; const size = firmware.file_size || firmware.size || firmware.fileSize || 0; const sizeStr = size ? `(${formatBytes(size)})` : ''; const releaseDate = firmware.release_date || firmware.releaseDate || ''; const checksum = firmware.checksum_md5 || firmware.checksum_sha256 || firmware.checksum || ''; if (!url) { return; } const item = document.createElement('div'); item.className = 'portal-radio-item'; const meta = document.createElement('div'); meta.className = 'portal-radio-meta'; const name = document.createElement('strong'); name.textContent = version; if (sizeStr) { name.textContent += ' ' + sizeStr; } meta.appendChild(name); if (releaseDate) { const dateSpan = document.createElement('span'); dateSpan.style.fontSize = '12px'; dateSpan.style.color = '#718096'; dateSpan.textContent = ` (${releaseDate})`; meta.appendChild(dateSpan); } if (description) { const detail = document.createElement('p'); detail.style.margin = '4px 0'; detail.style.fontSize = '13px'; detail.textContent = description; meta.appendChild(detail); } if (checksum) { const checksumSpan = document.createElement('span'); checksumSpan.style.fontSize = '11px'; checksumSpan.style.color = '#a0aec0'; checksumSpan.textContent = `Checksum: ${checksum.substring(0, 16)}...`; meta.appendChild(checksumSpan); } const urlLine = document.createElement('span'); urlLine.style.fontSize = '12px'; urlLine.style.color = '#4a5568'; urlLine.textContent = url; meta.appendChild(urlLine); const btn = document.createElement('button'); btn.className = 'portal-radio-select'; btn.textContent = 'Ch·ªçn firmware'; btn.onclick = function() { selectPortalFirmware(url, version); }; item.appendChild(meta); item.appendChild(btn); portalOtaListEl.appendChild(item); }); } function selectPortalFirmware(url, version) { document.getElementById('ota_firmware_url').value = url; showStatus(`ƒê√£ ch·ªçn firmware: ${version}`, false); } function formatBytes(bytes) { if (bytes === 0) return '0 Bytes'; const k = 1024; const sizes = ['Bytes', 'KB', 'MB', 'GB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i]; } function buildPortalFirmwareEndpoint() { if (!portalConfig) return null; const base = portalConfig.firmware_endpoint || (portalConfig.portal_base_url ? portalConfig.portal_base_url + 'index.php?api=firmware_list' : null); if (!base) return null; const separator = base.includes('?') ? '&' : '?'; return `${base}${separator}token=${encodeURIComponent(deviceMacAddress)}&output=esp32`; } async function loadPortalFirmwareList() { if (!ensureOtaPortalElements()) return; const endpoint = buildPortalFirmwareEndpoint(); if (!endpoint) { setPortalOtaStatus('Thi·∫øu c·∫•u h√¨nh endpoint firmware.', true); return; } setPortalOtaStatus('üîÑ ƒêang t·∫£i danh s√°ch firmware VIP t·ª´ portal...'); try { const response = await fetch(endpoint); if (!response.ok) { const errorText = await response.text(); console.error('Portal firmware fetch HTTP error:', response.status, errorText); if (response.status === 403) { setPortalOtaStatus('Thi·∫øt b·ªã ch∆∞a ƒë∆∞·ª£c k√≠ch ho·∫°t VIP ho·∫∑c kh√¥ng c√≥ quy·ªÅn truy c·∫≠p.', true); } else { setPortalOtaStatus('L·ªói khi t·∫£i danh s√°ch firmware: HTTP ' + response.status, true); } portalOtaListEl.innerHTML = ''; return; } const textResponse = await response.text(); let data; try { data = JSON.parse(textResponse); } catch (jsonError) { console.error('Failed to parse JSON from portal firmware list:', jsonError, 'Response:', textResponse.substring(0, 200)); setPortalOtaStatus('L·ªói ƒë·ªãnh d·∫°ng d·ªØ li·ªáu t·ª´ portal. Ki·ªÉm tra l·∫°i API.', true); portalOtaListEl.innerHTML = ''; return; } let firmwareList = []; if (Array.isArray(data)) { firmwareList = data; } else if (data.vip_required) { setPortalOtaStatus('Thi·∫øt b·ªã ch∆∞a ƒë∆∞·ª£c k√≠ch ho·∫°t VIP. Vui l√≤ng ƒëƒÉng k√Ω tr√™n portal.', true); portalOtaListEl.innerHTML = ''; return; } else if (data.error) { setPortalOtaStatus('L·ªói t·ª´ portal: ' + data.error, true); portalOtaListEl.innerHTML = ''; return; } else if (Array.isArray(data.firmware)) { firmwareList = data.firmware; } else if (Array.isArray(data.list)) { firmwareList = data.list; } else if (data.data && Array.isArray(data.data)) { firmwareList = data.data; } if (!firmwareList.length) { setPortalOtaStatus('Kh√¥ng t√¨m th·∫•y firmware n√†o cho thi·∫øt b·ªã n√†y. Ki·ªÉm tra l·∫°i tr·∫°ng th√°i VIP ho·∫∑c tham s·ªë API.', true); portalOtaListEl.innerHTML = ''; return; } portalFirmwareList = firmwareList; renderPortalFirmwareList(firmwareList); setPortalOtaStatus('Ch·ªçn m·ªôt firmware VIP b√™n d∆∞·ªõi ƒë·ªÉ n√¢ng c·∫•p.'); } catch (error) { console.error('Portal firmware fetch error', error); setPortalOtaStatus('Kh√¥ng th·ªÉ k·∫øt n·ªëi portal. Ki·ªÉm tra m·∫°ng ho·∫∑c tr·∫°ng th√°i VIP. Error: ' + error.message, true); portalOtaListEl.innerHTML = ''; } } async function tryFetchPortalFirmwareList(force = false) { if (!ensureOtaPortalElements()) return; if (!portalConfig || !deviceMacAddress) return; if (portalOtaFetchRequested && !force) return; portalOtaFetchRequested = true; await loadPortalFirmwareList(); } function initPortalOtaSection() { if (!ensureOtaPortalElements()) return; if (portalConfig && deviceMacAddress) { tryFetchPortalFirmwareList(); } else { fetchPortalConfig().then(() => { if (deviceMacAddress) { tryFetchPortalFirmwareList(); } }); } } if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', function() { setTimeout(initPortalOtaSection, 1500); }); } else { setTimeout(initPortalOtaSection, 1500); } function ensureAssetsPortalElements() { if (!portalAssetsStatusEl) { portalAssetsStatusEl = document.getElementById('portal-assets-status'); } if (!portalAssetsListEl) { portalAssetsListEl = document.getElementById('portal-assets-list'); } return portalAssetsStatusEl !== null && portalAssetsListEl !== null; } function setPortalAssetsStatus(message, isError = false) { if (!ensureAssetsPortalElements()) return; portalAssetsStatusEl.textContent = message; if (isError) { portalAssetsStatusEl.classList.add('error'); } else { portalAssetsStatusEl.classList.remove('error'); } } function renderPortalAssetsList(l){if(!ensureAssetsPortalElements()||!l||l.length===0)return;portalAssetsListEl.innerHTML='';for(let i=0;i<l.length;i++){const a=l[i];const u=a.file_url||a.url||a.download_url||a.link||'';if(!u)continue;const n=a.name||a.title||'Assets kh√¥ng t√™n';const v=a.version||'';const t=a.type||'';const d=a.description||a.info||a.desc||'';const s=a.file_size?`(${formatBytes(a.file_size)})`:'';const p=a.preview_image_url||a.preview||'';const it=document.createElement('div');it.className='portal-radio-item';if(p){const ic=document.createElement('div');ic.style.cssText='width:80px;height:80px;flex-shrink:0;margin-right:12px;border-radius:6px;overflow:hidden;border:1px solid #e2e8f0';const im=document.createElement('img');im.src=p;im.style.cssText='width:100%;height:100%;object-fit:cover';im.onerror=function(){ic.style.display='none';};ic.appendChild(im);it.appendChild(ic);}const m=document.createElement('div');m.className='portal-radio-meta';m.style.flex='1';const ne=document.createElement('strong');ne.textContent=(t?`[${t.toUpperCase()}] `:'')+n+(v?` v${v}`:'');m.appendChild(ne);if(d||s){const dt=document.createElement('span');dt.textContent=(d+' '+s).trim();m.appendChild(dt);}const ul=document.createElement('span');ul.style.fontSize='12px';ul.style.color='#4a5568';ul.textContent=u;m.appendChild(ul);const b=document.createElement('button');b.className='portal-radio-select';b.textContent='Ch·ªçn assets';b.onclick=function(){selectPortalAssets(u,n);};it.appendChild(m);it.appendChild(b);portalAssetsListEl.appendChild(it);}} function selectPortalAssets(url, version) { document.getElementById('assets_url').value = url; showStatus(`ƒê√£ ch·ªçn assets: ${version}`, false); } function buildPortalAssetsEndpoint() { if (!portalConfig) return null; const base = portalConfig.assets_endpoint || (portalConfig.portal_base_url ? portalConfig.portal_base_url + 'index.php?api=assets' : null); if (!base) return null; const separator = base.includes('?') ? '&' : '?'; return `${base}${separator}token=${encodeURIComponent(deviceMacAddress)}&output=esp32`; } async function loadPortalAssetsList() { if (!ensureAssetsPortalElements()) return; const endpoint = buildPortalAssetsEndpoint(); if (!endpoint) { setPortalAssetsStatus('Thi·∫øu c·∫•u h√¨nh endpoint assets.', true); return; } setPortalAssetsStatus('üîÑ ƒêang t·∫£i danh s√°ch assets VIP t·ª´ portal...'); try { const response = await fetch(endpoint); if (!response.ok) { throw new Error('HTTP ' + response.status); } const data = await response.json(); let assetsList = []; const ts=['themes','fonts','sounds','images'],tm={'themes':'theme','fonts':'font','sounds':'sound','images':'image'}; for(let i=0;i<ts.length;i++){const t=ts[i];if(data[t]&&Array.isArray(data[t])){for(let j=0;j<data[t].length;j++){const a=data[t][j];a.type=tm[t];assetsList.push(a);}}} if(assetsList.length===0){ if(Array.isArray(data))assetsList=data; else if(data.vip_required){setPortalAssetsStatus('Thi·∫øt b·ªã ch∆∞a ƒë∆∞·ª£c k√≠ch ho·∫°t VIP. Vui l√≤ng ƒëƒÉng k√Ω tr√™n portal.',true);portalAssetsListEl.innerHTML='';return;} else if(Array.isArray(data.assets))assetsList=data.assets; else if(Array.isArray(data.list))assetsList=data.list; else if(data.data&&Array.isArray(data.data))assetsList=data.data; } if (!assetsList.length) { setPortalAssetsStatus('Kh√¥ng t√¨m th·∫•y assets VIP n√†o cho thi·∫øt b·ªã n√†y. Ki·ªÉm tra l·∫°i API ho·∫∑c tr·∫°ng th√°i VIP.', true); portalAssetsListEl.innerHTML = ''; return; } portalAssetsList = assetsList; renderPortalAssetsList(assetsList); setPortalAssetsStatus('Ch·ªçn m·ªôt assets VIP b√™n d∆∞·ªõi ƒë·ªÉ n√¢ng c·∫•p.'); } catch (error) { console.error('Portal assets fetch error', error); setPortalAssetsStatus('Kh√¥ng th·ªÉ k·∫øt n·ªëi portal. Ki·ªÉm tra m·∫°ng ho·∫∑c tr·∫°ng th√°i VIP. Error: ' + error.message, true); portalAssetsListEl.innerHTML = ''; } } async function tryFetchPortalAssetsList(force = false) { if (!ensureAssetsPortalElements()) return; if (!portalConfig || !deviceMacAddress) return; if (portalAssetsFetchRequested && !force) return; portalAssetsFetchRequested = true; await loadPortalAssetsList(); } function initPortalAssetsSection() { if (!ensureAssetsPortalElements()) { return; } if (portalConfig && deviceMacAddress) { tryFetchPortalAssetsList(); } else { fetchPortalConfig().then(() => { if (deviceMacAddress) { tryFetchPortalAssetsList(); } }); } } function startAssetsPortalInit() { console.log('Starting assets portal initialization...'); setTimeout(() => { initPortalAssetsSection(); }, 2000); } if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', startAssetsPortalInit); } else { startAssetsPortalInit(); } function escapeHtml(text) { const div = document.createElement('div'); div.textContent = text; return div.innerHTML; } async function loadSettings() { try { const res = await fetch('/api/settings'); const data = await res.json(); if (data.music_server_url) document.getElementById('music_server_url').value = data.music_server_url; if (data.alarm_music_url) document.getElementById('alarm_music_url').value = data.alarm_music_url; if (data.alarm_timeout) document.getElementById('alarm_timeout').value = data.alarm_timeout; if (data.sleep_mode !== undefined) document.getElementById('sleep_mode').checked = data.sleep_mode; if (data.wake_word_sensitivity !== undefined) { document.getElementById('wake_word_sensitivity').value = data.wake_word_sensitivity; updateWakeWordSensitivity(); } if (data.wake_word_during_music !== undefined) { document.getElementById('wake_word_during_music').checked = data.wake_word_during_music; } if (data.vad_mode !== undefined) { document.getElementById('vad_mode').value = data.vad_mode; } if (data.vad_min_noise_ms !== undefined) { document.getElementById('vad_min_noise_ms').value = data.vad_min_noise_ms; updateVadMinNoiseMs(); } if (data.noise_suppression_enabled !== undefined) { document.getElementById('noise_suppression_enabled').checked = data.noise_suppression_enabled; } if (data.qr_duration !== undefined) { document.getElementById('qr_duration').value = data.qr_duration; } } catch (e) { console.error('Failed to load settings:', e); } } async function loadAlarms() { try { const res = await fetch('/api/alarms'); const data = await res.json(); const list = document.getElementById('alarms-list'); list.innerHTML = ''; data.alarms.forEach(alarm => { const div = document.createElement('div'); div.className = 'alarm-item'; div.innerHTML = '<strong>' + alarm.time + '</strong> - ' + alarm.message + '<button class="delete-btn" onclick="deleteAlarm(\'' + alarm.id + '\')">Delete</button>'; list.appendChild(div); }); } catch (e) { console.error('Failed to load alarms:', e); } } async function saveSettings() { try { const res = await fetch('/api/settings', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ music_server_url: document.getElementById('music_server_url').value, sleep_mode: document.getElementById('sleep_mode').checked, wake_word_sensitivity: parseFloat(document.getElementById('wake_word_sensitivity').value), wake_word_during_music: document.getElementById('wake_word_during_music').checked, vad_mode: parseInt(document.getElementById('vad_mode').value), vad_min_noise_ms: parseInt(document.getElementById('vad_min_noise_ms').value), noise_suppression_enabled: document.getElementById('noise_suppression_enabled').checked }) }); const data = await res.json(); if (data.success) { showStatus('Settings saved!', false); } else { showStatus('Failed to save: ' + data.message, true); } } catch (e) { showStatus('Error: ' + e.message, true); } } async function saveAlarmMusic() { try { const url = document.getElementById('alarm_music_url').value; const timeout = parseInt(document.getElementById('alarm_timeout').value) || 120; const res = await fetch('/api/settings', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ alarm_music_url: url, alarm_timeout: timeout }) }); const data = await res.json(); if (data.success) { showStatus('Alarm music settings saved!', false); } else { showStatus('Failed to save: ' + data.message, true); } } catch (e) { showStatus('Error: ' + e.message, true); } } async function addAlarm() { try { const time = document.getElementById('new_alarm_time').value; const daysStr = document.getElementById('new_alarm_days').value; const message = document.getElementById('new_alarm_message').value; const days = daysStr.split(',').map(d => parseInt(d.trim())).filter(d => !isNaN(d)); const res = await fetch('/api/alarms', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ time, days, message }) }); const data = await res.json(); if (data.success) { showStatus('Alarm added!', false); hideAddAlarm(); loadAlarms(); } else { showStatus('Failed: ' + data.message, true); } } catch (e) { showStatus('Error: ' + e.message, true); } } async function deleteAlarm(id) { try { const res = await fetch('/api/alarms/' + id, { method: 'DELETE' }); const data = await res.json(); if (data.success) { showStatus('Alarm deleted!', false); loadAlarms(); } else { showStatus('Failed: ' + data.message, true); } } catch (e) { showStatus('Error: ' + e.message, true); } } function showAddRadioChannel() { document.getElementById('add-radio-form').style.display = 'block'; } function hideAddRadioChannel() { document.getElementById('add-radio-form').style.display = 'none'; document.getElementById('new_radio_title').value = ''; document.getElementById('new_radio_url').value = ''; document.getElementById('new_radio_artist').value = ''; } async function loadRadioChannels() { try { const res = await fetch('/api/radio/channels'); const data = await res.json(); const list = document.getElementById('radio-channels-list'); list.innerHTML = ''; data.forEach((channel, idx) => { const div = document.createElement('div'); div.className = 'alarm-item'; div.innerHTML = '<strong>' + (idx + 1) + '. ' + channel.title + '</strong><br>' + 'URL: ' + channel.url + (channel.artist ? '<br>Artist: ' + channel.artist : '') + '<button class="delete-btn" onclick="deleteRadioChannel(' + idx + ')">Delete</button>'; list.appendChild(div); }); } catch (e) { console.error('Failed to load radio channels:', e); } } async function addRadioChannel() { const title = document.getElementById('new_radio_title').value.trim(); const url = document.getElementById('new_radio_url').value.trim(); const artist = document.getElementById('new_radio_artist').value.trim(); if (!title || !url) { showStatus('Title and URL are required', true); return; } try { const res = await fetch('/api/radio/channels'); const channels = await res.json(); channels.push({ title: title, url: url, artist: artist || '', duration: 'N/A' }); const saveRes = await fetch('/api/radio/channels', { method: 'PUT', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(channels) }); const data = await saveRes.json(); if (data.success) { showStatus('Radio channel added!', false); hideAddRadioChannel(); loadRadioChannels(); } else { showStatus('Failed: ' + data.message, true); } } catch (e) { showStatus('Error: ' + e.message, true); } } async function deleteRadioChannel(idx) { try { const res = await fetch('/api/radio/channels'); const channels = await res.json(); channels.splice(idx, 1); const saveRes = await fetch('/api/radio/channels', { method: 'PUT', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(channels) }); const data = await saveRes.json(); if (data.success) { showStatus('Radio channel deleted!', false); loadRadioChannels(); } else { showStatus('Failed: ' + data.message, true); } } catch (e) { showStatus('Error: ' + e.message, true); } } async function saveRadioChannels() { try { const res = await fetch('/api/radio/channels'); const channels = await res.json(); const saveRes = await fetch('/api/radio/channels', { method: 'PUT', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(channels) }); const data = await saveRes.json(); if (data.success) { showStatus('Radio channels saved!', false); loadRadioChannels(); } else { showStatus('Failed: ' + data.message, true); } } catch (e) { showStatus('Error: ' + e.message, true); } } let chatMessages = []; function renderChatMessage(entry) { const text = entry.text || ''; const sender = entry.sender || 'user'; const timeStr = entry.timestamp || new Date().toLocaleTimeString('vi-VN', {hour: '2-digit', minute: '2-digit'}); const messagesContainer = document.getElementById('chat-messages'); const emptyMessage = messagesContainer.querySelector('div[style*="text-align: center"]'); if (emptyMessage) { emptyMessage.remove(); } const messageDiv = document.createElement('div'); messageDiv.className = 'chat-message'; messageDiv.style.cssText = ` display: flex; margin-bottom: 15px; animation: slideIn 0.3s ease-out; ${sender === 'user' ? 'justify-content: flex-end;' : 'justify-content: flex-start;'} `; const messageBubble = document.createElement('div'); messageBubble.style.cssText = ` max-width: 70%; padding: 12px 16px; border-radius: 18px; word-wrap: break-word; box-shadow: 0 2px 4px rgba(0,0,0,0.1); ${sender === 'user' ? 'background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-bottom-right-radius: 4px;' : 'background: #f0f0f0; color: #333; border-bottom-left-radius: 4px;'} `; const messageText = document.createElement('div'); messageText.style.cssText = 'font-size: 14px; line-height: 1.5; white-space: pre-wrap;'; messageText.textContent = text; messageBubble.appendChild(messageText); const timeSpan = document.createElement('div'); timeSpan.style.cssText = ` font-size: 11px; margin-top: 4px; opacity: 0.7; ${sender === 'user' ? 'color: rgba(255,255,255,0.8);' : 'color: #666;'} `; timeSpan.textContent = timeStr; messageBubble.appendChild(timeSpan); messageDiv.appendChild(messageBubble); messagesContainer.appendChild(messageDiv); messagesContainer.scrollTop = messagesContainer.scrollHeight; } function addChatMessage(text, sender, timestamp = null) { const timeStr = timestamp instanceof Date ? timestamp.toLocaleTimeString('vi-VN', {hour: '2-digit', minute: '2-digit'}) : (timestamp || new Date().toLocaleTimeString('vi-VN', {hour: '2-digit', minute: '2-digit'})); const entry = {text, sender, timestamp: timeStr}; chatMessages.push(entry); saveChatHistory(); renderChatMessage(entry); } function showTypingIndicator() { const indicator = document.getElementById('typing-indicator'); indicator.style.display = 'block'; let dots = 0; const dotsInterval = setInterval(() => { dots = (dots + 1) % 4; document.getElementById('typing-dots').textContent = '.'.repeat(dots); }, 500); indicator.dataset.interval = dotsInterval; } function hideTypingIndicator() { const indicator = document.getElementById('typing-indicator'); indicator.style.display = 'none'; if (indicator.dataset.interval) { clearInterval(parseInt(indicator.dataset.interval)); } } function saveChatHistory() { try { localStorage.setItem('xiaozhi_chat_history', JSON.stringify(chatMessages)); } catch (e) { console.warn('Failed to save chat history:', e); } } function loadChatHistory() { try { const saved = localStorage.getItem('xiaozhi_chat_history'); if (saved) { chatMessages = JSON.parse(saved); const messagesContainer = document.getElementById('chat-messages'); messagesContainer.innerHTML = ''; chatMessages.forEach(msg => renderChatMessage(msg)); } } catch (e) { console.warn('Failed to load chat history:', e); } } function clearChat() { if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a to√†n b·ªô l·ªãch s·ª≠ chat?')) { chatMessages = []; const messagesContainer = document.getElementById('chat-messages'); messagesContainer.innerHTML = '<div style="text-align: center; color: #999; padding: 20px; font-size: 14px;">üí¨ B·∫Øt ƒë·∫ßu cu·ªôc tr√≤ chuy·ªán v·ªõi AI...</div>'; saveChatHistory(); } } async function sendTextToAI() { const textInput = document.getElementById('ai_text_input'); const text = textInput.value.trim(); if (!text) { showStatus('Vui l√≤ng nh·∫≠p tin nh·∫Øn', true); return; } textInput.disabled = true; const sendButton = document.getElementById('send-button'); sendButton.disabled = true; sendButton.textContent = '‚è≥ ƒêang g·ª≠i...'; addChatMessage(text, 'user'); textInput.value = ''; textInput.style.height = 'auto'; showTypingIndicator(); try { const res = await fetch('/api/ai/send', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ text: text }) }); const data = await res.json(); hideTypingIndicator(); if (data.success) { addChatMessage('‚úÖ Tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn AI. Ph·∫£n h·ªìi s·∫Ω hi·ªÉn th·ªã tr√™n thi·∫øt b·ªã.', 'ai'); showStatus('Tin nh·∫Øn ƒë√£ g·ª≠i th√†nh c√¥ng!', false); } else { addChatMessage('‚ùå L·ªói: ' + (data.message || 'Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn'), 'ai'); showStatus('L·ªói: ' + (data.message || 'Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn'), true); } } catch (e) { hideTypingIndicator(); addChatMessage('‚ùå L·ªói k·∫øt n·ªëi: ' + e.message, 'ai'); showStatus('L·ªói: ' + e.message, true); } finally { textInput.disabled = false; sendButton.disabled = false; sendButton.textContent = 'üì§ G·ª≠i'; textInput.focus(); } } loadSettings(); loadAlarms(); loadRadioChannels(); loadQrSettings(); checkVipStatus(); const textInput = document.getElementById('ai_text_input'); textInput.addEventListener('keydown', function(e) { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendTextToAI(); } }); textInput.addEventListener('input', function() { this.style.height = 'auto'; this.style.height = Math.min(this.scrollHeight, 120) + 'px'; }); loadChatHistory(); async function upgradeFirmware() { const url = document.getElementById('ota_firmware_url').value.trim(); if (!url) { showStatus('Please enter firmware URL', true); return; } if (!confirm('‚ö†Ô∏è C·∫£nh b√°o: N√¢ng c·∫•p firmware s·∫Ω kh·ªüi ƒë·ªông l·∫°i thi·∫øt b·ªã. B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën ti·∫øp t·ª•c?')) { return; } const statusDiv = document.getElementById('ota-status'); statusDiv.style.display = 'block'; statusDiv.textContent = 'ƒêang b·∫Øt ƒë·∫ßu n√¢ng c·∫•p firmware...'; statusDiv.style.background = '#fff3cd'; statusDiv.style.color = '#856404'; try { const res = await fetch('/api/ota/upgrade', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ url: url }) }); const data = await res.json(); if (data.success) { statusDiv.textContent = '‚úÖ N√¢ng c·∫•p firmware ƒë√£ b·∫Øt ƒë·∫ßu! Thi·∫øt b·ªã s·∫Ω kh·ªüi ƒë·ªông l·∫°i sau khi ho√†n t·∫•t.'; statusDiv.style.background = '#d4edda'; statusDiv.style.color = '#155724'; showStatus('Firmware upgrade started!', false); } else { statusDiv.textContent = '‚ùå L·ªói: ' + (data.message || 'Unknown error'); statusDiv.style.background = '#f8d7da'; statusDiv.style.color = '#721c24'; showStatus('Failed: ' + (data.message || 'Unknown error'), true); } } catch (e) { statusDiv.textContent = '‚ùå L·ªói k·∫øt n·ªëi: ' + e.message; statusDiv.style.background = '#f8d7da'; statusDiv.style.color = '#721c24'; showStatus('Error: ' + e.message, true); } } async function upgradeAssets() { const url = document.getElementById('assets_url').value.trim(); if (!url) { showStatus('Please enter assets URL', true); return; } if (!confirm('‚ö†Ô∏è L∆∞u √Ω: Upgrade assets s·∫Ω t·∫£i v√† flash file assets m·ªõi. B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën ti·∫øp t·ª•c?')) { return; } const statusDiv = document.getElementById('assets-status'); statusDiv.style.display = 'block'; statusDiv.textContent = 'ƒêang b·∫Øt ƒë·∫ßu t·∫£i assets...'; statusDiv.style.background = '#fff3cd'; statusDiv.style.color = '#856404'; try { const res = await fetch('/api/assets/upgrade', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ url: url }) }); const data = await res.json(); if (data.success) { statusDiv.textContent = '‚úÖ Upgrade assets ƒë√£ b·∫Øt ƒë·∫ßu! Vui l√≤ng ƒë·ª£i qu√° tr√¨nh download v√† flash ho√†n t·∫•t.'; statusDiv.style.background = '#d4edda'; statusDiv.style.color = '#155724'; showStatus('Assets upgrade started!', false); } else { statusDiv.textContent = '‚ùå L·ªói: ' + (data.message || 'Unknown error'); statusDiv.style.background = '#f8d7da'; statusDiv.style.color = '#721c24'; showStatus('Failed: ' + (data.message || 'Unknown error'), true); } } catch (e) { statusDiv.textContent = '‚ùå L·ªói k·∫øt n·ªëi: ' + e.message; statusDiv.style.background = '#f8d7da'; statusDiv.style.color = '#721c24'; showStatus('Error: ' + e.message, true); } } function updateWakeWordSensitivity() { const slider = document.getElementById('wake_word_sensitivity'); if (!slider) return; const value = parseFloat(slider.value); const db = (20 * Math.log10(value)).toFixed(1); const valueSpan = document.getElementById('wake_word_sensitivity_value'); const dbSpan = document.getElementById('wake_word_sensitivity_db'); if (valueSpan) valueSpan.textContent = value.toFixed(1); if (dbSpan) dbSpan.textContent = '~' + db; } function updateVadMinNoiseMs() { const slider = document.getElementById('vad_min_noise_ms'); if (!slider) return; const value = parseInt(slider.value); const valueSpan = document.getElementById('vad_min_noise_ms_value'); if (valueSpan) valueSpan.textContent = value; } async function loadDeviceInfo() { try { const response = await fetch('/api/device/info'); if (!response.ok) { throw new Error('Failed to fetch device info'); } const data = await response.json(); const macElement = document.getElementById('mac-address'); if (macElement && data.device_id) { const macAddress = data.device_id.replace(/-/g, ':'); macElement.textContent = macAddress; deviceMacAddress = macAddress; tryFetchPortalMusicServers(); tryFetchPortalRadioChannels(); if(portalConfig&&!portalConfig.vip_checked)checkVipFromPortal(); } const ipElement = document.getElementById('ip-address'); if (ipElement && data.ip_address) { ipElement.textContent = data.ip_address + (data.port ? ':' + data.port : ''); } else if (ipElement) { ipElement.textContent = 'Kh√¥ng c√≥'; } const deviceIdElement = document.getElementById('device-id'); if (deviceIdElement && data.device_id) { deviceIdElement.textContent = data.device_id; } } catch (error) { console.error('Error loading device info:', error); deviceMacAddress = null; const macElement = document.getElementById('mac-address'); if (macElement) { macElement.textContent = 'L·ªói khi t·∫£i th√¥ng tin'; macElement.style.color = '#f44336'; } } } function copyMacAddress(event) { const macElement = document.getElementById('mac-address'); if (!macElement) return; const macAddress = macElement.textContent.trim(); if (macAddress === 'ƒêang t·∫£i...' || macAddress === 'L·ªói khi t·∫£i th√¥ng tin') { alert('MAC address ch∆∞a s·∫µn s√†ng'); return; } const button = event ? event.target : document.querySelector('button[onclick="copyMacAddress()"]'); if (navigator.clipboard && navigator.clipboard.writeText) { navigator.clipboard.writeText(macAddress).then(function() { if (button) { const originalText = button.textContent; button.textContent = '‚úÖ ƒê√£ copy!'; button.style.background = '#4caf50'; setTimeout(function() { button.textContent = originalText; button.style.background = '#667eea'; }, 2000); } }).catch(function(err) { console.error('Failed to copy:', err); alert('Kh√¥ng th·ªÉ copy. Vui l√≤ng copy th·ªß c√¥ng: ' + macAddress); }); } else { const textArea = document.createElement('textarea'); textArea.value = macAddress; textArea.style.position = 'fixed'; textArea.style.opacity = '0'; document.body.appendChild(textArea); textArea.select(); try { document.execCommand('copy'); if (button) { const originalText = button.textContent; button.textContent = '‚úÖ ƒê√£ copy!'; button.style.background = '#4caf50'; setTimeout(function() { button.textContent = originalText; button.style.background = '#667eea'; }, 2000); } } catch (err) { alert('Kh√¥ng th·ªÉ copy. Vui l√≤ng copy th·ªß c√¥ng: ' + macAddress); } document.body.removeChild(textArea); } } if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', loadDeviceInfo); } else { loadDeviceInfo(); } if ('serviceWorker' in navigator) { window.addEventListener('load', function() { navigator.serviceWorker.register('/service-worker.js') .then(function(registration) { console.log('ServiceWorker registration successful with scope: ', registration.scope); }) .catch(function(err) { console.log('ServiceWorker registration failed: ', err); }); }); } let deferredPrompt = null; let pwaBanner = null; let pwaInstallBtn = null; function initPWA() { pwaBanner = document.getElementById('pwa-install-banner'); pwaInstallBtn = document.getElementById('pwa-install-btn'); if (!pwaBanner) { console.warn('PWA banner element not found'); return; } console.log('PWA banner initialized'); if (isPWAInstalled()) { console.log('PWA already installed, hiding banner'); pwaBanner.style.display = 'none'; return; } if (wasBannerDismissed()) { console.log('PWA banner was dismissed, hiding'); pwaBanner.style.display = 'none'; return; } setTimeout(function() { if (pwaBanner && !isPWAInstalled() && !wasBannerDismissed()) { console.log('Showing PWA install banner'); pwaBanner.style.display = 'block'; } }, 1000); } function isPWAInstalled() { return window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true || document.referrer.includes('android-app://') function wasBannerDismissed() { return localStorage.getItem('pwa-banner-dismissed') === 'true'; } function showPWAInstallBanner() { if (!pwaBanner) { pwaBanner = document.getElementById('pwa-install-banner'); } if (isPWAInstalled() || wasBannerDismissed()) { return; } if (pwaBanner) { console.log('Force showing PWA banner'); pwaBanner.style.display = 'block'; } } function installPWA() { console.log('installPWA called, deferredPrompt:', deferredPrompt ? 'available' : 'null'); if (deferredPrompt) { console.log('Triggering browser install prompt - dialog s·∫Ω xu·∫•t hi·ªán'); try { deferredPrompt.prompt(); deferredPrompt.userChoice.then(function(choiceResult) { console.log('User choice from browser prompt:', choiceResult.outcome); if (choiceResult.outcome === 'accepted') { console.log('User accepted - browser will install app automatically'); if (pwaBanner) { pwaBanner.style.display = 'none'; } localStorage.setItem('pwa-banner-dismissed', 'true'); } else { console.log('User dismissed the install prompt'); } deferredPrompt = null; }).catch(function(err) { console.error('Error in userChoice promise:', err); deferredPrompt = null; }); } catch (err) { console.error('Error calling prompt():', err); alert('L·ªói khi m·ªü dialog c√†i ƒë·∫∑t. Vui l√≤ng c√†i ƒë·∫∑t th·ªß c√¥ng t·ª´ menu browser (‚ãÆ ‚Üí Install app).'); } } else { console.log('No deferredPrompt - browser may not support automatic install prompt'); if (/Android/.test(navigator.userAgent) && /Chrome/.test(navigator.userAgent)) { alert('ƒê·ªÉ c√†i ƒë·∫∑t ·ª©ng d·ª•ng tr√™n Android/Chrome:\n\n' + '1. Nh·∫•n menu (3 ch·∫•m ‚ãÆ) ·ªü g√≥c tr√™n b√™n ph·∫£i\n' + '2. Ch·ªçn "C√†i ƒë·∫∑t" ho·∫∑c "Install app"\n' + '3. Nh·∫•n "C√†i ƒë·∫∑t" trong dialog'); } else if (/iPhone|iPad|iPod/.test(navigator.userAgent)) { alert('ƒê·ªÉ c√†i ƒë·∫∑t tr√™n iOS:\n\n' + '1. Nh·∫•n n√∫t Share (m≈©i t√™n l√™n)\n' + '2. Cu·ªôn xu·ªëng v√† ch·ªçn "Add to Home Screen"\n' + '3. Nh·∫•n "Add"'); } else { alert('ƒê·ªÉ c√†i ƒë·∫∑t ·ª©ng d·ª•ng:\n\n' + 'üì± Android/Chrome: Nh·∫•n menu (‚ãÆ) ‚Üí "Install app"\n' + 'üíª Desktop: Nh·∫•n bi·ªÉu t∆∞·ª£ng (+) tr√™n thanh ƒë·ªãa ch·ªâ'); } } } function dismissPWA() { if (pwaBanner) { pwaBanner.style.display = 'none'; } localStorage.setItem('pwa-banner-dismissed', 'true'); console.log('PWA banner dismissed'); } window.addEventListener('beforeinstallprompt', function(e) { console.log('beforeinstallprompt event fired - browser supports automatic install'); e.preventDefault(); deferredPrompt = e; if (pwaInstallBtn) { pwaInstallBtn.textContent = 'C√†i ƒë·∫∑t ngay'; } showPWAInstallBanner(); }); window.addEventListener('appinstalled', function(evt) { console.log('PWA app was installed successfully by browser'); if (pwaBanner) { pwaBanner.style.display = 'none'; } localStorage.setItem('pwa-banner-dismissed', 'true'); }); if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initPWA); } else { initPWA(); } setTimeout(function() { if (!isPWAInstalled() && !wasBannerDismissed()) { console.log('Fallback: showing banner after 2 seconds'); showPWAInstallBanner(); } else { console.log('Banner not shown - installed:', isPWAInstalled(), 'dismissed:', wasBannerDismissed()); } }, 2000); console.log('PWA Status - Installed:', isPWAInstalled(), 'Dismissed:', wasBannerDismissed()); window.clearPWADismissed = function() { localStorage.removeItem('pwa-banner-dismissed'); console.log('PWA dismissed state cleared, reload page to see banner'); };